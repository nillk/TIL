# Chapter 6. 전진하라

대부분의 현대 언어들은 객체지향형, 메타객체형, 함수형 등의 패러다임을 다 지원하는 다중 패러다임을 갖고 있다. 문제에 적합한 패러다임을 사용하는 법을 배우는 것이 더 좋은 개발자로 진화하는 길 중 하나이다.

## 6.1 함수형 언어의 디자인 패턴

혹자는 함수형 프로그래밍에서는 디자인 패턴\(흔한 문제들을 푸는 방법으로서 분류되고 이름이 붙은 해법들\)이 필요가 없다고 주장한다. 하지만 그런 주장은 패턴의 사용보다는 의미론에 국한된 것이며, 디자인 패턴의 개념은 아직도 건재하다. 다만 다른 패러다임에서 패턴들은 다른 형태로 나타난다. 함수형에서는 빌딩블록과 문제의 접근 방법이 다르기 때문에, 전통적인 GoF 패턴들 중의 일부는 사라지고, 나머지는 근본적으로 다른 방법으로 같은 문제를 풀게 된다.

함수형 프로그래밍에서는 전통적인 디자인 패턴들이 다음과 같은 세 가지로 나타난다.

* 패턴이 언어에 _흡수_ 된다.
* 패턴 해법이 함수형 패러다임에도 존재하지만, _구체적인 구현 방식은 다르다._
* 해법이 _다른 언어나 패러다임에 없는 기능으로 구현_ 된다. 예를 들어 메타프로그래밍을 사용한 해법들은 깔끔하고 멋있다. 이런 해법은 자바에서는 불가능하다.

## 6.2 함수 수준의 재사용

구성\(composition\)은 함수형 프로그래밍 라이브러리에서 재사용의 방식으로 자주 사용된다. 함수형 언어들은 객체지향 언어들보다 더 큰 단위로 재사용을 한다. 객체지향 시스템은 메시지 전달\(좀 더 구체적으로 말하자면 메서드 실행\)을 통해 소통하는 객체들로 구성되어 있다. 유용한 클래스들과 메시지들을 발견하면, 재사용을 위해 추출한다. 디자인 패턴을 이렇게 _추출된 패턴들의 카탈로그_ 인 셈이다. 하지만 디자인 패턴을 통한 재사용은 궁극적으로 작은 단위의 재사용이다. 한 가지의 해법은 다른 것과 전혀 상관이 없다. \(예를 들어 경량급 패턴은 메멘토 패턴과 전혀 상관이 없다\) 디자인 패턴으로 해결할 수 있는 문제들은 아주 특정하고, 그 문제에만 적용되기 때문에 사용 범위는 좁을 수밖에 없다.

함수형 프로그래밍도 코드를 재사용하지만, 다른 빌딩블록을 사용한다. 구조물들 간에 잘 알려진 관계\(커플링 coupling\)를 만들기보다는, 큰 단위의 재사용 메커니즘을 추출하려 한다. 이런 노력은 객체 간의 관계\(모피즘 morphism\)를 규정하는 수학의 한 분야인 _카테고리 이론_ 에 근거를 둔다. 함수형 접근 방법은 목록을 중심으로 재사용 메커니즘을 구축하며, 이때 사용되는 것이 상황에 따라 달라지고\(contextualized\) 이동 가능한\(portable\) 코드다.

궁극적으로 디자인 패턴의 존재 목적은 쓸데 없이 뼈대뿐인 클래스에 래핑하지 않고는 행동을 전달할 수 없는 결함을 메꾸기 위함일 뿐이다. 코드를 매개변수로 전달하는 기능은 코드 재사용의 다른 접근 방법을 제시해준다.

### 6.2.1 템플릿 메서드

일급 함수를 사용하면 불필요한 구조물들을 없앨 수 있다. 템플릿 메서드는 클래스의 뼈대만 정의하고, 세부 절차는 하위 클래스가 주어진 알고리즘의 구조를 바꾸지 않고 정의하게 한다. 일급 함수는 자료구조처럼 사용할 수 있으므로, 굳이 추상 메서드를 선언하는 일을 할 필요 없이 상세 구현을 나중으로 미룰 수 있다. 고계 함수 덕분에 명령 패턴이나 템플릿 패턴 등 고전적 패턴에서 자주 사용되는 보일러플레이트 코드가 필요 업어진다.

### 6.2.2 전략

전략 패턴은 각자 캡슐화되어 서로 교환 가능한 알고리즘 군을 정의한다. 코드 블록을 일급 함수로 사용하여, 전략을 쉽게 만들고 조작할 수 있다. 전통적인 방법이 바람직할 때도 있다. 하지만 그런 경우 거기에 따르는 제약 조건\(같은 클래스나 인터페이스를 상속해야 하는 등\)을 어길 수 업지만, 코드 블록을 사용해 조금 더 유연하게 구현할 수 있다. 이건 함수형 프로그래밍과 디자인 패턴 논의라기 보다는 동적 언어와 정적 언어의 논의라 하겠다.

### 6.2.3 플라이웨이트 디자인 패턴과 메모이제이션

플라이웨이트 패턴은 많은 수의 조밀한 객체의 참조들을 공유하는 최적화 기법이다. 참조들을 객체 풀에 생성하여 특정 뷰를 위해 사용한다. 전통적인 디자인 패턴에서는, 메서드를 구현한 새 클래스를 팩토리로 사용한다. 함수형에서는 하나의 메서드를 구현한 후 메모아이즈된 버전을 리턴한다. 캐싱처럼 세부적 사항을 런타임에 맡기면 직접 구현한 코드가 실패할 기회가 적어진다.

### 6.2.4 팩토리와 커링

디자인 패턴 차원에서 보면, 커링은 함수의 팩토리처럼 사용된다. 함수를 여느 자료구조처럼 사용할 수 있게 해주는 함수형 프로그래밍 언어의 일급 함수는 _주어진 조건에 따라 다른 함수들을 리턴하는 함수_ 를 만들 수 있다.

```scala
object CurryTest extends App {
  def filter(xs: List[Int], p: Int => Boolean): List[Int] =
    if (xs.isEmpty) xs
    else if (p(xs.head)) xs.head :: filter(xs.tail, p)
    else filter(xs.tail, p)

  def dividesBy(n: Int)(x: Int) = ((x % n) == 0)

  val nums = List(1, 2, 3, 4, 5, 6, 7, 8)

  println(filter(nums, dividesBy(2)))
  println(filter(nums, dividesBy(3)))
}
```

위 예제는 함수형 프로그래밍에서의 패턴의 두 가지 형태를 보여준다. 1. 커링이 언어나 런타임에 내장되어 있기 때문에, 함수 팩토리의 개념이 이미 녹아들어 있어 다른 구조물이 필요 없다. 2. 다양한 구현 방법에 대한 중요성을 보여준다. 대부분의 자바 개발자에게 위와 같은 예제는 생소할 것이다. 같은 코드를 여기 저기 쉽게 사용할 수 없을 뿐 아니라, 일반화된 함수에서 특정한 함수를 만들어낼 생각도 할 수 없다.

## 6.3 구조형 재사용과 함수형 재사용

객체지향의 한 가지 목적은 캡슐화와 상태 조작을 쉽게 하는 것이다. 그래서 객체지향형 추상화는 문제 해결을 위해 주로 상태를 이용한다. _움직이는 부분_ 인 클래스와 클래스 간의 상호 관계를 주로 사용하게 된다. 하지만 함수형 프로그래밍은 구조물들을 연결하기보다는 부분들로 구성하여 움직이는 부분을 최소화 하려고 노력한다.

### 6.3.1 구조물을 사용한 코드 재사용

명령형 및 객체지향형 프로그래밍에서는 구조물과 메시징이 빌딩블록이다. 객체지향 코드를 재사용하려면, 대상이 되는 코드를 다른 클래스로 옮기고 상속을 통해 접근해야 한다. 여기서는 자연수 분류기와 소수 찾기 코드를 이용해 설명하겠다. 두 문제 다 약수를 사용하기 때문에 좋은 예제가 될 것이다.

#### 중복 코드를 제거하는 리팩토링

이런 경우 중복된 코드를 해결하는 방법은 약수를 구하는 부분을 하나의 클래스로 리팩토링하는 것이다. 그리고 자연수 분류기와 소수 찾기 부분이 약수를 구하는 클래스를 상속하게 하면 코드가 간단해진다. 이것은 문제의 부분들을 분리해주기 때문에 종종 이롭기도 하지만, 상위 클래스를 바꾸면 하위 클래스에도 영향을 주는 문제점이 있다.

이것이 _커플링 coupling_ 을 통한 코드 재사용의 일례이다. 상위 클래스의 `number` 변수와 `getFactors()` 메서드를 공유함으로써 클래스를 서로 묶어버리는 방법이다. 객체지향은 커플링된 상호 작용 스타일을 정의한다. 따라서 커플링 방식을 정하는 규칙들이 있고, 이런 규칙들은 동작을 일관되게 이해하는 데 도움이 될 수 있다. 하지만 이 방식은 객체지향 언어에서 더 나은 성질을 가진 다른 추상 개념 대신에 남용되고 있다.

#### 구성을 사용한 코드 재사용

공유된 상태\(이전 예제의 `number`\)를 제거하고 모두 매개변수로 받기로 한다. 커플링과 구성의 차이점은 작지만 중요하다. 무성하게 커플링된 구조물들을 이해해야 하는 어려움 때문에 객체지향 언어에서는 코드 재사용이 피해를 많이 입었다.

여기서는 디자인 패턴이 함수형 프로그래밍과 만나는 방법들의 윤곽을 살펴 봤다. 1. 디자인 패턴은 언어나 런타임에 흡수될 수 있다. \(팩토리, 전략, 싱글턴, 템플릿 메서드 패턴의 예\) 2. 패턴들은 그 의미를 보존하면서 다른 방법으로 구현될 수 있다. \(플라이웨이트 패턴을 클래스와 메모이제이션을 사용해 구현한 예\) 3. 함수형 언어와 런타임은 전적으로 다른 기능을 가질 수 있고, 그것들을 사용하면 같은 문제라도 완전히 다른 방식으로 풀어나갈 수 있다.

