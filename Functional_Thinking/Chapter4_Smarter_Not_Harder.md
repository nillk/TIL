## Chapter 4. 열심히보다는 현명하게
함수형 언어에서 보편적인 두 가지 기능 **메모이제이션** 과 **게으름** 을 알아본다.

### 4.1 메모이제이션
연속해서 사용되는 연산 값을 함수 레벨에서 캐시하는 것을 지칭. 시간이 많이 걸리는 연산을 반복적으로 사용할 때 유용하다. 보편적인 방법은 내장 캐시를 설정하는 것인데, 캐싱 방법이 제대로 작동하려면 함수가 **순수** 해야 한다. 주어진 매개 변수에 대해 항상 같은 값을 리턴해야 하기 때문이다.

#### 4.1.1 캐싱
##### 메서드 레벨에서의 캐싱
이전 장에서의 자연수 분류 문제의 `Classifier` 클래스는 자연수를 분류한다. 분류를 위해 같은 수를 이 클래스의 여러 메서드에 주는 일이 다반사이다. 하지만 이전과 같이 구현한 경우, 분류 메서드를 호출할 때마다 매개변수의 합을 매번 계산해야 한다. 이는 상당히 비효율적인 접근 방법이다. 클래스 내부 캐싱(intraclass caching)의 예(???)이다.

##### 합산 결과를 캐시하기
이미 수행된 결과를 재사용하는 것이 코드를 효율적으로 만드는 한 방법이다. 그래서 아래와 같이 계산 결과를 저장할 캐시를 만들었다. 이것이 외부 캐싱(???)의 예이다. 캐시된 결과는 호출하는 모든 코드가 사용하게 되며, 그래서 두 번재 시도는 무척 빨라진다.

```groovy
class ClassifierCachedSum {
  private sumCache = [:]

  def sumOfFactors(number) {
    if (! sumCache.containsKey(number)) {
      sumCache[number] = factorsOf(number).sum()
    }

    return sumCache[number]
  }
}
```

캐시하면 성능이 엄청나게 좋아지지만 거기엔 트레이드 오프가 있다. 메모리와 성능의 관계도 그렇지만, `ClassifierCachedSum` 클래스는 순수한 정적 메서드만 가질 수는 없다. 내부 캐시가 *상태*를 표시하기 때문에 이 캐시를 사용하는 모든 메서드를 인스턴스 메서드로 만들어야 한다. 개발자가 캐시 변수를 제어하기 때문에 직접 정확성을 테스트나 다른 방법을 사용하여 확인해야 한다. 성능은 향상시켰지만, 코드를 복잡하게 하고 유지 보수를 어렵게 하는 대가를 치뤄야 한다.

##### 전부 다 캐시하기
합 만이 아니라 모든 값을 다 캐시한다면? 속도 측면에서 봤을 때 결과는 매우 좋지만, 이 방법은 규모를 늘리기가 어렵다. (java.lang.OutOfMemoryError: Java heap space..........T_T) 캐싱 코드를 작성하는 개발자는 정확함과 함께 실행 조건도 신경써야 한다. 이것이 *움직이는 부분*ㅡ이 적절한 예이다. 코드 내의 상태와 그 의미를 개발자가 항상 관리해야만 한다.

#### 4.1.2 메모이제이션의 첨가
함수형 프로그래밍은 런타임에 재사용 가능한 메커니즘을 만들어서 움직이는 부분을 최소화하는 데 주력한다. 메모이제이션은 프로그래밍 언어에 내장되어 반복되는 함수의 리턴 값을 자동으로 캐싱해주는 기능이다.

그루비에서 함수를 메모아이즈 하기 위해서는 함수를 클로저로 정의하고, 리턴 값이 캐시되는 함수를 리턴하는 `memoize()` 메서드를 실행해야 한다. 함수를 메모아이즈하는 것은 *메타함수*를 적용하는 것이라고 할 수 있다. 즉 리턴 값이 아니라 함수에 어떤 것을 적용하는 것이다. 커링도 하나의 메타함수 기법이다.

앞에서 전부 다 캐싱했던 것처럼, 여기서도 전부 다 메모이제이션 할 수 있다. 하지만 여기서도 마찬가지로 무분별하게 사용하다가는 메모리가 바닥날 것이다. 명령형 기법이 잘 작동하기 위해서는 안전장치와 함께 실행 조건에 대한 조심스러운 배려가 필요하다. 이것 역시 하나의 *움직이는 부분* 인 셈이다.

수작업으로 캐시를 만드는 것 역시 간단하기는 하지만, 함수형 언어의 메모이제이션 같은 기능을 사용하면 함수 레벨에서 캐시를 더할 수 있어서, 코드를 거의 바꾸지 않고도 명령형보다 간단하게 더 좋은 성능을 얻게 된다.

대부분의 함수형 언어들은 메모이제이션을 내장하거나 그것을 구현하기 쉽게끔 되어 있다. 클로저에서도 `(memoize )` 함수로 어떤 함수든지 메모아이즈 할 수 있다. 스칼라는 메모이제이션을 직접 구현하지는 않지만 컬렉션의 `getOrElseUpdate()` 메서드를 쓰면 대부분 간단하게 가능하다.

메모아이즈된 함수의 결과가 *매개변수 이외의 어떤 것에라도 의존*하면 기대하는 결과를 얻을 수 없다. 메모아이즈 하는 대상은 불변해야 한다. 함수에 부수효과가 있다면 캐시된 값이 리턴되어도 그 값을 믿을 수 없다.

메모아이즈된 함수는
* 부수효과가 없어야 하고
* 외부 정보에 절대로 의존하지 말아야 한다.

### 4.2 게으름
게으른 평가는 표현의 평가를 가능한 최대로 늦추는 기법이다. 이 기법엔 몇 가지 이점이 있다.

1. 시간이 많이 걸리는 연산을 반드시 필요할 때까지 미룰 수 있게 된다
2. 요청이 계속되는 한 요소를 계속 전달하는 무한 컬렉션을 만들 수 있다
3. 맵이나 필터 같은 함수형 개념을 게으르게 사용하면 효율이 높은 코드를 만들 수 있다

#### 4.2.1 자바의 게으른 반복자
자바는 게으른 컬렉션을 네이티브로 지원하지 않지만, Iterator를 사용하면 흉내를 낼 수는 있다.

#### 4.2.2 토털리 레이지 자연수 분류기
[토털리 레이지](https://code.google.com/p/totallylazy)는 장황하게나마 자바 구문을 함수형 메커니즘 쪽으로 바꿔주는 자바 프레임워크이다. 여기의 코드에서는 몇 개의 정적 임포트를 사용했는데, 정적 임포트 다음의 코드는 전형적인 자바 같지는 않지만 가독성은 훨씬 좋다. 자바는 연산자 오버로딩을 지원하지 않기 때문에 토털리 레이지는 적당한 메소드를 작성했다. 토털리 레이지는 가능한 한 많은 연산을 지연시킴으로써 게으름을 적극적으로 사용한다.

전통적인 게으른 자료구조를 만들려면 고계함수가 있으면 유용하다.

#### 4.2.3 그루비의 게으른 목록
함수형 언어의 대표적인 기능은 내용물을 필요할 때만 만들어내는 게으른 목록이다. 이는 1. 초기화하기 어려운 리소스를 반드시 필요할 때까지 지연할 수 있게 해주고 2. 목록이 얼마나 긴지를 명시할 필요가 없다면 끝 없는 무한 수열을 만들 수 있다.

게으른 목록은 완전수의 목록 생성처럼 각 요소를 생성하는 비용이 큰 경우에 적합하다.

##### 완전수의 게으른 목록
이전까지의 완전수를 구하는 방법들의 문제 중 하나는 분류를 하기 위해서 분류할 수를 지정해야 한다는 것이다. 이번엔 완전수의 목록을 리턴하는 버전이 있으면 좋겠다고 해보자. 완전수를 구하는 연산은 비용이 큰 일이다. 여기서 게으른 목록을 사용하면 필요할 때까지 이 연산을 미룰 수 있다. 목록을 *번호가 붙은 슬롯들*로 추상화한다면 무한수열은 이해하기가 어렵다. 목록을 *첫 요소*와 *나머지 요소들*로 생각하면 목록을 그 내부 구조보다는 요소들로서 생각할 수 있게 된다.

#### 4.2.4 게으른 목록 만들기
언어는 **엄격한** (모든 표현을 그때 그때 평가), **게으른** (평가를 꼭 필요할 때까지 미룸) 언어로 구분된다. 그루비는 근본적으로는 엄격한 언어이지만 클로저 내부에 엄격한 목록을 재귀적으로 포함해서 게으르지 않은 목록을 게으른 목록으로 변형할 수 있다.

#### 4.2.5 게으름의 이점
게으른 목록의 첫번째 이점은 무한 수열을 만들 수 있다는 것이고, 두번째는 저장 시 크기가 줄어든다는 것이다. 컬렉션 전부를 유지하지 않고 그때마다 다음 값을 유도할 수 있으니 저장소와 실행 속도를 맞바꿀 수 있다. 그리고 셋째 이점은 런타임이 좀 더 효율적일 코드를 만들 수 있다는 점이다.

문장에서 회문을 찾는 예문에서 게으른 연산을 사용하지 않는다면, 언어는 전체 문자열(아무리 길지라도)을 공백으로 자른 후에, 전체 문자열을 계산해 회문을 찾아낼 것이다. 이 경우 금방 버려질 엄청나게 큰 자료구조가 만들어질 수도 있다.

그루비는 기본적으로 게으르지 않다. 그루비에서 클로저로 바뀌는 과정은 단순한 구문 변화 이상을 의미한다. 클로저의 모든 자료구조는 가능한 한 게으르게 만들어진다. 스칼라는 모든 것을 게으르게 만드는 대신, 컬렉션에서 게으른 뷰를 제공한다.

#### 4.2.6 게으른 필드 초기화
스칼라에서는 `val`을 선언하는 곳 앞에 `lazy`를 사용하면 필드를 적극적 평가에서 게으른 평가로 간단히 바꿀 수 있다. 그루비에도 유사한 기능이 있는데, 이 기능은 **추상 구문 트리** (Abstract Syntax Tree) 변형이라는 고급 언어 기능을 사용하며, 컴파일러가 AST를 생성하는 작업과 연동하여 저수준에서 사용자가 변형을 조작할 수 있게 한다. 이 예 중 하나는 `@Lazy` 속성이다. 이는 처음 사용되기 전까지는 값이 정해지지 않는다. 그루비는 게으르게 초기화된 필드를 소프트 레퍼런스에 유지하게 만들 수도 있다. 이는 필요에 따라 가비지 컬렉트되는 자바식 포인터 참조를 말한다.
