# Chapter 6. 객체와 자료 구조

왜 변수는 `private`으로 선언하면서 `get`이나 `set` 함수를 `public`으로 만드는 걸까?

## 6.1 자료 추상화

단순히 `interface`를 사용하거나 `get`, `set` 함수를 넣는다고 해서 구현이 감춰지는 것은 아니다. 구현을 감추려면 _추상화_가 필요하다. 우리는 사용자가 구현을 모른 채 _자료의 핵심을 조작_할 수 있도록 객체가 포함하는 자료를 표현해야 한다. 또 그 과정에서 우리는 클래스에 대한 접근 정책을 결정할 수도 있다.

## 6.2 자료/객체 비대칭

객체와 자료 구조 개념은 사실상 정 반대이다. 한 쪽에서 쉬운 것은 한 쪽에서 어렵고, 한 쪽에서 어려운 것은 다른 한 쪽에서 쉽다. 한 쪽이 무조건 옳은 것은 아니다.

### 객체

추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개

* \(객체 지향 코드는\) 기존 함수를 변경하지 않으면서 _새 클래스를 추가_하기 쉬움
* 새 함수를 추가하면 모든 클래스를 고쳐야 함
* 새로운 함수가 아니라 새로운 자료 타입이 필요한 경우 클래스와 객체 지향 기법이 가장 적합

### 자료 구조

자료를 그대로 공개하며 별다른 함수는 제공하지 않음

* \(자료 구조를 사용하는 절차 지향 코드는\) 기존 자료 구조를 변경하지 않으면서 _새 함수를 추가_하기 쉬움
* 새 자료 구조를 추가하면 모든 함수를 고쳐야 함
* 새로운 자료 타입이 아니라 새로운 함수가 필요한 경우 자료 구조와 절차적 코드가 적합

## 6.3 디미터 법칙

모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다. 좀 더 정확히 말하자면, _클래스 C의 메서드 f는 다음 객체의 메서드만 호출해야 한다._ 그리고 허용된 메서드가 반환하는 객체의 메서드는 호출하면 안 된다.

* 클래스 C
* f가 생성한 객체
* f 인수로 넘어온 객체
* C 인스턴스 변수에 저장된 객체

```java
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath(); // 디미터 법칙을 어기는 것 같은데?
```

### 기차 충돌

방금 전 예시와 같은 코드를 기차 충돌이라고 부른다. 그럼 아래와 같이 고치면 될까?

```java
Options opts = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();
```

이 문제는 `ctxt`, `opts`, `scratchDir`가 객체인지 자료구조인지에 달렸다. 객체라면 내부 구조를 숨겼어야 했으므로 디미터 법칙을 위배한다. 자료구조라면 그렇지 않다. 하지만 조회 함수를 사용했기 때문에 혼란을 일으킨다. 그렇다면 코드를 아래와 같이 고치면 되지 않을까?

```java
final String outputDir = ctxt.options.scratchDir.absolutePath;
```

자료 구조는 무조건 함수 없이 공개 변수만 포함하고 객체는 `private` 변수와 `public` 함수를 포함한다면, 문제는 훨씬 간단해질 것이다.

### 잡종 구조

반은 객체이고 반은 자료 구조인 구조... 새로운 함수도 추가 하기 어렵고 새로운 자료 구조도 마찬가지로 추가하기 어렵다. 양쪽에서 단점만 모아놓은 구조이니 쓰지 말자.

### 구조체 감추기

만약 `ctxt`, `opts`, `scratchDir`가 정말 객체라면?

```java
/* 대안 */
// 1. ctxt 객체에 public 메서드가 너무 많아짐
ctxt.getAbsolutePathOfScratchDirectoryOption();
// 2. getScratchDirectoryOption이 자료 구조를 반환한다고 가정함
ctxt.getScratchDirectoryOption().getAbsolutePath();
```

`ctxt`가 객체라면 _뭔가를 하라고 해야지 속을 드러내라고 하면 안 됨_

코드를 따라 내려가보니, 절대 경로를 얻어서 임시 파일을 생성하는 것이 목적이라는 것을 알았다. 그럼 이렇게 고치면 어떨까?

```java
BufferedOutputStream bos = ctxt.createScratchFileStream(classFileName);
```

`ctxt`에게 임시 파일을 생성하라고 시켰다! `ctxt`는 내부 구조를 드러내지 않을 뿐더러, 우리는 몰라도 되는 여러 객체를 탐색할 필요도 없어졌다.

## 6.4 자료 전달 객체

자료 구조체의 전형적인 형태는 _공개 변수만 있고 함수가 없는 클래스_인데, 이런 자료 구조체를 떄로 **자료 전달 객체 Data Transfer Object\(DTO\)** 라고 한다. DTO는 데이터 베이스와 통신하거나 소켓에서 받은 메시지 구문을 분석할 떄 유용하다.

### 활성 레코드

DTO의 특수한 형태로, `save`나 `find`같은 탐색 함수도 제공한다. 활성 레코드는 데이터 베이스 테이블이나 다른 소스에서 자료를 직접 변환한 결과다. 하지만 여기에 비즈니스 규칙 메서드를 추가하면 안 된다. 이는 잡종 구조이다. 활성 레코드는 자료 구조로 취급하고, 비지니스 규칙을 담는 객체는 따로 생성하자.

## 6.5 결론

객체는 동작을 공개하고 자료를 숨긴다. 그래서 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기는 쉽지만, 기존 객체에 새 동작을 추가하기는 어렵다. 따라서 새로운 자료 타입을 추가해야 할 필요가 있는 경우에 적합하다.

자료 구조는 별다른 동작 없이 자료를 노출한다. 그래서 기존 자료 구조에 새 동작을 추가하기는 쉬우나, 기존 함수에 새 자료 구조를 추가하기는 어렵다. 따라서 새로운 동작을 추가해야 할 필요가 있는 경우에 적합하다.

