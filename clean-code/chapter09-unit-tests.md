# Chapter 9. 단위 테스트

과거에 단위테스트는 코드가 **돌아간다**는 사실을 확인하기 위한 일회성 코드(작동 확인 후에 삭제될)에 불과했다. 하지만 지난 시간 동안 애자일과 TDD 덕에 테스팅 분야에 많은 발전이 있었고, 현재는 많은 프로그래머들이 테스트 코드를 작성한다.

그렇다면, 제대로 된 테스트 케이스는 어떻게 작성할까.

## 9.1 TDD 법칙 세 가지

기본적으로 TDD는 **실제 코드를 작성하기 전에 단위 테스트부터 작성**하길 권한다. 여기 더 근본적인 법칙 세 가지가 있다.

1. _실패하는 단위테스트_ 를 작성하기 전까지 실제코드를 작성하지 말 것
2. 컴파일은 실패하지 않지만, 실행은 실패하는 정도로만 단위 테스트를 작성할 것
3. _현재 실패하는 테스트를 통과할 정도_ 로만 실제 코드를 작성할 것

이런 식으로 테스트 코드를 작성하면 개발과 테스트가 거의 30초 주기로 묶이며, 반복하다보면 전체 프로그램을 커버하는 테스트코드를 작성할 수 있다.

하지만, 실제로 이렇게 방대한 테스트 코드가 문제를 유발하기도 한다.

## 9.2 클린 테스트 코드 유지하기

테스트 코드는 지저분해도 된다고 생각하는가? 실제 코드의 작동만을 확인하면 되는가? 테스트 코드를 깨끗하게 유지하는 데 드는 노력이 아까울 수도 있다. 하지만, 과거에 짜왔던 일회용 테스트 코드를 작성하는 일과 _자동화된 단위 테스트_ 를 작성하는 일은 매우 다르다.

* 실제 코드가 진화하면 테스트 코드도 같이 진화해야 함
* 지저분한 테스트 코드는 실제 코드와 마찬가지로 갈수록 유지 보수 비용이 증가
* 지저분한 테스트 코드를 통과하게 만드는 것이 부담이 되면 될수록 테스트 코드는 버려짐
* 하지만 제대로 동작하는 테스트 코드가 없으면 코드를 수정해도 프로그램이 제대로 동작하는지 확인할 방법이 없음
* 결국 개발자는 코드 변경이나 코드를 정리하는 일을 주저하게 됨
* 점점 실제 코드도 지저분해지고 망가지기 시작

테스트 코드를 짤 때도 실제 코드 못지않게 사고와 설계와 주의가 필요하다. 테스트 코드는 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이다. _테스트 코드가 있어야 실제 코드를 안심하고 개선할 수 있다._ 결국 자동화된 단위 테스트 코드가 설계와 아키텍처를 최대한 깨끗하게 보존할 수 있는 열쇠다.

## 9.3 클린 테스트 코드

클린 테스트 코드에 무엇보다 중요한 것은 **가독성**이다. 어쩌면 실제코드에서보다 테스트 코드에서 더 가독성이 중요하다.

추상화 수준이 낮은 잡다하고 세세한 코드들을 없애고 함수, 유틸리티 등으로 구현해 _테스트에서 사용하는 특수 API로_ 만들자. 앞으로 테스트 코드를 읽는 사람은 바로 그 테스트 코드가 무엇을 하는지 알 수 있다.

### 해당 분야에 밀접한 테스트 언어

테스트에서 사용하는 레벨로 테스트 코드에서 사용하는 특수 API로 만들면 테스트 코드를 작성하는 사람과 후에 테스트 코드를 읽을 사람 모두를 도와주는 _일종의 테스트 언어가 된다._

### 이중 표준

테스트 코드 역시 단순하고, 간결하고, 표현력이 풍부하게 유지해야 하지만, 실제 코드만큼 효율적일 필요는 없다.

실제 코드에서는 사용하지 말아야 할 축약어 등의 경우도 맥락을 파악하고 있는 테스트 코드에서는 오히려 코드를 더 간결하고 보기 쉽게 해줄 수 있다.

* 간단한 예시: heater, blower, cooler, hi-temp-alarm, lo-temp-alarm의 순으로, 대문자는 켜져 있고, 소문자는 꺼져 있음을 의미

    ```java
    @Test
    public void turnOnCollerAndBlowerIfTooHot() throws Exception {
      tooHot();
      assertEquals("hBChl", hw.getState());
    }

    @Test
    public void turnOnHeaterAndBlowerIfTooCold() throws Exception {
      tooCold();
      assertEquals("HBchl", hw.getState());
    }

    @Test
    public void turnOnHiTempAlarmAtThreshold() throws Exception {
      wayTooHot();
      assertEquals("hBCHl", hw.getState());
    }
    ```

또한 실제 코드가 구동되는 환경은 훨씬 제약적일 수 있다. 하지만 테스트 코드가 작성되는 환경은 그렇지 않다. 메모리나 CPU, 네트워크 같은 환경 들을 테스트 코드에서는 고려하지 않아도 될 수도 있다. 따라서 표준은 달라질 수밖에 없다.

## 9.4 테스트 당 `assert` 하나

테스트 코드 하나 당 `assert` 문이 하나여야 한다고 주장하는 사람들이 있다. 가혹하다고 여길 수도 있지만, `assert` 문이 단 하나인 함수는 _결론이 하나_ 이므로 코드를 이해하기가 쉽다.

하지만 예를 들어 출력이 XML이라는 `assert` 문과 특정 문자열을 포함한다는 `assert` 문은 하나로 만들기가 쉽지 않다. 그렇다고 테스트 코드를 두 개로 쪼개면 중복되는 코드가 많아진다. 그러면 템플릿 메서드 패턴을 사용하거나, 테스트 클래스를 따로 만들어서 `@Before`에 공통 부분을 집어 넣거나...

배보다 배꼽이 커! 훌륭한 지침이긴 하지만 그냥 `assert` 문을 여러 개 사용하는 편이 낫다. (대신 최소한의 개수로)

### 테스트 당 개념 하나

_테스트 함수마다 개념 하나만 테스트하라_ 는 규칙이 더 나은 것 같다. 하나의 테스트에 하나의 개념만 표현하게 되면 일반적인 규칙이 한 눈에 들어온다.

## 9.5 F.I.R.S.T

클린 테스트의 다섯 가지 규칙

1. Fast: 테스트 코드 _수행 시간은 빨라야 한다._ 느리면 자주 못 돌리고, 자주 못 돌리면 문제를 찾기 어렵고, 코드를 마음껏 정리하기도 어렵다.
2. Independent: 각 테스트가 _서로 의존하면 안된다._ 각 테스트를 독립적으로, 어떤 순서로 실행해도 통과해야 한다. 테스트 코드가 서로 의존하게 되면 한 테스트 코드가 실패했을 때 의존하는 다른 테스트 코드들도 실패하게 되고, 어떤 코드가 실패했는지 정확하게 원인을 찾아내기가 어렵다.
3. Repeatable: 테스트는 _반복 가능해야 한다._ 실제 환경, QA, 개발 환경 등 모든 환경에서 테스트는 수행되어야 한다. 환경을 변명으로 만들면 안 된다.
4. Self-Validating: 테스트는 _참/거짓(bool) 값으로 결과를 내야 한다._ 즉, 성공 아니면 실패다. 통과 여부를 수동으로 확인(눈으로 직접 본다든지, 파일을 직접 비교한다든지)해서는 안 된다.
5. Timely: 테스트는 _적시에 작성해야 한다._ 실제 코드 작성하기 전에 작성해야 한다. 실제 코드부터 작성하게 되면, 실제 코드가 테스트 하기 어렵거나, 심지어 테스트 코드 작성이 불가능할 수도 있다.

## 9.6 결론

테스트 코드는 실제 코드만큼, 어쩌면 실제 코드보다 더 중요하다. 테스트 코드는 실제 코드의 유연성, 유지보수성, 재사용성을 보존하고 강화한다. 테스트 코드가 망가지면 실제 코드도 망가진다.

* 테스트 코드를 지속적으로 깨끗하게 관리할 것
* 테스트 코드의 표현력을 높이고 간결하게 정리할 것
* 테스트 API를 구현해 해당 분야 언어를 만들 것
